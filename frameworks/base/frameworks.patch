diff --git a/core/api/lint-baseline.txt b/core/api/lint-baseline.txt
index e71dffaf152d..6898d9e351f7 100644
--- a/core/api/lint-baseline.txt
+++ b/core/api/lint-baseline.txt
@@ -413,6 +413,10 @@ FlaggedApiLiteral: android.accessibilityservice.AccessibilityService#OVERLAY_RES
     @FlaggedApi contains a string literal, but should reference the field generated by aconfig (android.view.accessibility.Flags.FLAG_A11Y_OVERLAY_CALLBACKS).
 
 
+GetterSetterNullability: android.media.tv.ad.TvAdView#getOnUnhandledInputEventListener():
+    Nullability of android.media.tv.ad.TvAdView.OnUnhandledInputEventListener? in getter method android.media.tv.ad.TvAdView.getOnUnhandledInputEventListener() does not match android.media.tv.ad.TvAdView.OnUnhandledInputEventListener in corresponding setter method android.media.tv.ad.TvAdView.setOnUnhandledInputEventListener(android.media.tv.ad.TvAdView.OnUnhandledInputEventListener)
+
+
 InvalidNullabilityOverride: android.app.Notification.TvExtender#extend(android.app.Notification.Builder) parameter #0:
     Invalid nullability on parameter `builder` in method `extend`. Parameters of overrides cannot be NonNull if the super parameter is unannotated.
 InvalidNullabilityOverride: android.media.midi.MidiUmpDeviceService#onBind(android.content.Intent) parameter #0:
@@ -423,10 +427,34 @@ KotlinOperator: android.graphics.Matrix44#get(int, int):
     Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)
 KotlinOperator: android.graphics.Matrix44#set(int, int, float):
     Method can be invoked with an indexing operator from Kotlin: `set` (this is usually desirable; just make sure it makes sense for this type of object)
+KotlinOperator: android.hardware.DisplayLuts#set(android.hardware.DisplayLuts.Entry, android.hardware.DisplayLuts.Entry):
+    Method can be invoked with an indexing operator from Kotlin: `set` (this is usually desirable; just make sure it makes sense for this type of object)
+
 
+ManagerLookup: android.telephony.SubscriptionManager#createForAllUserProfiles():
+    Managers must always be obtained from Context (`createForAllUserProfiles`)
 
+
+MissingGetterMatchingBuilder: android.content.AttributionSource.Builder#setNextAttributionSource(android.content.AttributionSource):
+    android.content.AttributionSource does not declare a `getNextAttributionSource()` method matching method android.content.AttributionSource.Builder.setNextAttributionSource(android.content.AttributionSource)
 MissingGetterMatchingBuilder: android.os.RemoteCallbackList.Builder#setInterfaceDiedCallback(android.os.RemoteCallbackList.Builder.InterfaceDiedCallback<E>):
     android.os.RemoteCallbackList does not declare a `getInterfaceDiedCallback()` method matching method android.os.RemoteCallbackList.Builder.setInterfaceDiedCallback(android.os.RemoteCallbackList.Builder.InterfaceDiedCallback<E>)
+
+
+MissingNullability: android.app.WartControl#getForceCallClassPatterns():
+    Missing nullability on method `getForceCallClassPatterns` return
+MissingNullability: android.app.WartControl#getIgnoredClassPatterns():
+    Missing nullability on method `getIgnoredClassPatterns` return
+MissingNullability: android.app.WartControl#init(String) parameter #0:
+    Missing nullability on parameter `packageName` in method `init`
+MissingNullability: android.app.WartControl#shouldForceCall(String) parameter #0:
+    Missing nullability on parameter `className` in method `shouldForceCall`
+
+
+OnNameExpected: android.service.quickaccesswallet.QuickAccessWalletService#getGestureTargetActivityPendingIntent():
+    If implemented by developer, should follow the on<Something> style; otherwise consider marking final
+
+
 RequiresPermission: android.accounts.AccountManager#getAccountsByTypeAndFeatures(String, String[], android.accounts.AccountManagerCallback<android.accounts.Account[]>, android.os.Handler):
     Method 'getAccountsByTypeAndFeatures' documentation mentions permissions without declaring @RequiresPermission
 RequiresPermission: android.accounts.AccountManager#hasFeatures(android.accounts.Account, String[], android.accounts.AccountManagerCallback<java.lang.Boolean>, android.os.Handler):
@@ -1185,6 +1213,10 @@ UnflaggedApi: android.R.dimen#system_corner_radius_xlarge:
     New API must be flagged with @FlaggedApi: field android.R.dimen.system_corner_radius_xlarge
 UnflaggedApi: android.R.dimen#system_corner_radius_xsmall:
     New API must be flagged with @FlaggedApi: field android.R.dimen.system_corner_radius_xsmall
+UnflaggedApi: android.R.integer#status_bar_notification_info_maxnum:
+    Changes from not deprecated to deprecated must be flagged with @FlaggedApi: field android.R.integer.status_bar_notification_info_maxnum
+UnflaggedApi: android.R.string#status_bar_notification_info_overflow:
+    Changes from not deprecated to deprecated must be flagged with @FlaggedApi: field android.R.string.status_bar_notification_info_overflow
 UnflaggedApi: android.accessibilityservice.AccessibilityService#OVERLAY_RESULT_INTERNAL_ERROR:
     New API must be flagged with @FlaggedApi: field android.accessibilityservice.AccessibilityService.OVERLAY_RESULT_INTERNAL_ERROR
 UnflaggedApi: android.accessibilityservice.AccessibilityService#OVERLAY_RESULT_INVALID:
@@ -1335,6 +1367,20 @@ UnflaggedApi: android.app.Notification.TvExtender#setDeleteIntent(android.app.Pe
     New API must be flagged with @FlaggedApi: method android.app.Notification.TvExtender.setDeleteIntent(android.app.PendingIntent)
 UnflaggedApi: android.app.Notification.TvExtender#setSuppressShowOverApps(boolean):
     New API must be flagged with @FlaggedApi: method android.app.Notification.TvExtender.setSuppressShowOverApps(boolean)
+UnflaggedApi: android.app.WartControl:
+    New API must be flagged with @FlaggedApi: class android.app.WartControl
+UnflaggedApi: android.app.WartControl#getForceCallClassPatterns():
+    New API must be flagged with @FlaggedApi: method android.app.WartControl.getForceCallClassPatterns()
+UnflaggedApi: android.app.WartControl#getIgnoredClassPatterns():
+    New API must be flagged with @FlaggedApi: method android.app.WartControl.getIgnoredClassPatterns()
+UnflaggedApi: android.app.WartControl#getSleepTimeMillis():
+    New API must be flagged with @FlaggedApi: method android.app.WartControl.getSleepTimeMillis()
+UnflaggedApi: android.app.WartControl#init(String):
+    New API must be flagged with @FlaggedApi: method android.app.WartControl.init(String)
+UnflaggedApi: android.app.WartControl#isDumpEnabled():
+    New API must be flagged with @FlaggedApi: method android.app.WartControl.isDumpEnabled()
+UnflaggedApi: android.app.WartControl#shouldForceCall(String):
+    New API must be flagged with @FlaggedApi: method android.app.WartControl.shouldForceCall(String)
 UnflaggedApi: android.companion.AssociationInfo#getTag():
     New API must be flagged with @FlaggedApi: method android.companion.AssociationInfo.getTag()
 UnflaggedApi: android.companion.CompanionDeviceManager#clearAssociationTag(int):
@@ -1455,6 +1501,8 @@ UnflaggedApi: android.graphics.Gainmap#Gainmap(android.graphics.Gainmap, android
     New API must be flagged with @FlaggedApi: constructor android.graphics.Gainmap(android.graphics.Gainmap,android.graphics.Bitmap)
 UnflaggedApi: android.graphics.Path#computeBounds(android.graphics.RectF):
     New API must be flagged with @FlaggedApi: method android.graphics.Path.computeBounds(android.graphics.RectF)
+UnflaggedApi: android.graphics.Path#computeBounds(android.graphics.RectF, boolean):
+    Changes from deprecated to not deprecated must be flagged with @FlaggedApi: method android.graphics.Path.computeBounds(android.graphics.RectF,boolean)
 UnflaggedApi: android.graphics.fonts.FontFamily.Builder#buildVariableFamily():
     New API must be flagged with @FlaggedApi: method android.graphics.fonts.FontFamily.Builder.buildVariableFamily()
 UnflaggedApi: android.graphics.text.LineBreakConfig#LINE_BREAK_STYLE_UNSPECIFIED:
@@ -1629,3 +1677,11 @@ UnflaggedApi: android.view.inputmethod.InlineSuggestionsRequest.Builder#setClien
     New API must be flagged with @FlaggedApi: method android.view.inputmethod.InlineSuggestionsRequest.Builder.setClientSupported(boolean)
 UnflaggedApi: android.view.inputmethod.InlineSuggestionsRequest.Builder#setServiceSupported(boolean):
     New API must be flagged with @FlaggedApi: method android.view.inputmethod.InlineSuggestionsRequest.Builder.setServiceSupported(boolean)
+UnflaggedApi: android.view.inputmethod.InputMethodManager#hideSoftInputFromWindow(android.os.IBinder, int, android.os.ResultReceiver):
+    Changes from not deprecated to deprecated must be flagged with @FlaggedApi: method android.view.inputmethod.InputMethodManager.hideSoftInputFromWindow(android.os.IBinder,int,android.os.ResultReceiver)
+UnflaggedApi: android.view.inputmethod.InputMethodManager#showSoftInput(android.view.View, int, android.os.ResultReceiver):
+    Changes from not deprecated to deprecated must be flagged with @FlaggedApi: method android.view.inputmethod.InputMethodManager.showSoftInput(android.view.View,int,android.os.ResultReceiver)
+
+
+UserHandleName: android.service.notification.NotificationListenerService#createConversationNotificationChannelForPackage(String, android.os.UserHandle, String, String):
+    Method taking UserHandle should be named `doFooAsUser` or `queryFooForUser`, was `createConversationNotificationChannelForPackage`
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 48b74f2d0776..0d1519bdf48f 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -16,6 +16,24 @@
 
 package android.app;
 
+// wart-add
+import android.app.Application;
+import android.util.ArrayMap;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.InputStreamReader;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+
 import static android.app.ActivityManager.PROCESS_STATE_UNKNOWN;
 import static android.app.ConfigurationController.createNewConfigAndUpdateIfNotNull;
 import static android.app.Flags.skipBgMemTrimOnFgApp;
@@ -1002,6 +1020,318 @@ public final class ActivityThread extends ClientTransactionHandler
         }
     }
 
+    // wart-add
+    public static Field getClassField(ClassLoader classloader, String class_name,
+                                      String filedName) {
+
+        try {
+            Class obj_class = classloader.loadClass(class_name);//Class.forName(class_name);
+            Field field = obj_class.getDeclaredField(filedName);
+            field.setAccessible(true);
+            return field;
+        } catch (SecurityException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        }
+        return null;
+
+    }
+
+    // wart-add
+    public static Object getClassFieldObject(ClassLoader classloader, String class_name, Object obj,
+                                             String filedName) {
+
+        try {
+            Class obj_class = classloader.loadClass(class_name);//Class.forName(class_name);
+            Field field = obj_class.getDeclaredField(filedName);
+            field.setAccessible(true);
+            Object result = null;
+            result = field.get(obj);
+            return result;
+        } catch (SecurityException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }
+        return null;
+
+    }
+
+    // wart-add
+    public static Object invokeStaticMethod(String class_name,
+                                            String method_name, Class[] pareTyple, Object[] pareVaules) {
+
+        try {
+            Class obj_class = Class.forName(class_name);
+            Method method = obj_class.getMethod(method_name, pareTyple);
+            return method.invoke(null, pareVaules);
+        } catch (SecurityException e) {
+            e.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (NoSuchMethodException e) {
+            e.printStackTrace();
+        } catch (InvocationTargetException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        }
+        return null;
+
+    }
+
+    // wart-add
+    public static Object getFieldOjbect(String class_name, Object obj,
+                                        String filedName) {
+        try {
+            Class obj_class = Class.forName(class_name);
+            Field field = obj_class.getDeclaredField(filedName);
+            field.setAccessible(true);
+            return field.get(obj);
+        } catch (SecurityException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (NullPointerException e) {
+            e.printStackTrace();
+        }
+        return null;
+
+    }
+
+    // wart-add
+    public static ClassLoader getClassloader() {
+        Object currentActivityThread = invokeStaticMethod(
+                "android.app.ActivityThread", "currentActivityThread",
+                new Class[]{}, new Object[]{});
+        Object mBoundApplication = getFieldOjbect(
+                "android.app.ActivityThread", currentActivityThread,
+                "mBoundApplication");
+        Application mInitialApplication = (Application) getFieldOjbect("android.app.ActivityThread",
+                currentActivityThread, "mInitialApplication");
+        Object loadedApkInfo = getFieldOjbect(
+                "android.app.ActivityThread$AppBindData",
+                mBoundApplication, "info");
+        Application mApplication = (Application) getFieldOjbect("android.app.LoadedApk", loadedApkInfo, "mApplication");
+        return mApplication.getClassLoader();
+    }
+
+    // wart-add
+    public static void loadClassAndInvoke(ClassLoader appClassloader, String eachclassname, Method dumpMethodCode_method) {
+        final String TAG = "WART";
+        boolean shouldForceCall = WartControl.shouldForceCall(eachclassname);
+        Log.i(TAG, (shouldForceCall ? "[load]" : "[skip]") + " loadClassAndInvoke: " + eachclassname);
+        if(!shouldForceCall) return;
+        if (dumpMethodCode_method == null){
+            Log.e(TAG, "[loadClassAndInvoke] dumpMethodCode_method is null ");
+            return;
+        }
+        Class resultclass;
+        try {
+            resultclass = appClassloader.loadClass(eachclassname);
+        } catch (Throwable t) {
+            Log.e(TAG, "appClassloader.loadClass failed" , t);
+            return;
+        }
+        if (resultclass != null) {
+            try {
+                Constructor<?>[] cons = resultclass.getDeclaredConstructors();
+                for (Constructor<?> constructor : cons) {
+                    try {
+                        dumpMethodCode_method.invoke(null, constructor);
+                    } catch (Throwable t) {
+                        Log.e(TAG, "[DeclaredConstructors] dumpMethodCode_method failed" , t);
+                    }
+                }
+            } catch (Throwable t) {
+                Log.e(TAG, "[DeclaredConstructors] getDeclaredConstructors failed" , t);
+            }
+            Method[] methods = resultclass.getDeclaredMethods();
+            for (Method m : methods) {
+                try {
+                    dumpMethodCode_method.invoke(null, m);
+                } catch (Throwable t) {
+                    Log.e(TAG, "[DeclaredMethods] dumpMethodCode_method failed", t);
+                }
+            }
+        }
+    }
+
+    // wart-add
+    public static void wart() {
+        ClassLoader appClassloader = getClassloader();
+        ClassLoader parentClassloader = appClassloader.getParent();
+        if(!appClassloader.toString().contains("java.lang.BootClassLoader")) {
+            wartWithClassloader(appClassloader);
+        }
+        while(parentClassloader != null) {
+            if(!parentClassloader.toString().contains("java.lang.BootClassLoader")) {
+                wartWithClassloader(parentClassloader);
+            }
+            parentClassloader = parentClassloader.getParent();
+        }
+    }
+
+    // wart-add
+    public static void wartWithClassloader(ClassLoader appClassloader) {
+        final String TAG = "WART";
+
+        List<Object> dexFilesArray = new ArrayList<>();
+        Field pathList_Field;
+        Object pathList_object;
+        Object[] ElementsArray;
+        Field dexFile_fileField;
+        Class<?> DexFileClazz;
+        Method getClassNameList_method = null;
+        Method dumpMethodCode_method = null;
+        Method defineClass_method;
+        Method dumpDexFile_method;
+
+        try {
+            pathList_Field = getClassField(appClassloader, "dalvik.system.BaseDexClassLoader", "pathList");
+            pathList_object = getFieldOjbect("dalvik.system.BaseDexClassLoader", appClassloader, "pathList");
+            ElementsArray = (Object[]) getFieldOjbect("dalvik.system.DexPathList", pathList_object, "dexElements");
+
+            dexFile_fileField = getClassField(appClassloader, "dalvik.system.DexPathList$Element", "dexFile");
+            DexFileClazz = appClassloader.loadClass("dalvik.system.DexFile");
+        } catch (Throwable t) {
+            Log.e(TAG, "Fail to get DexPathList or DexFile class/field", t);
+            return;
+        }
+
+        for (Method m : DexFileClazz.getDeclaredMethods()) {
+            switch (m.getName()) {
+                case "getClassNameList":
+                    getClassNameList_method = m;
+                    getClassNameList_method.setAccessible(true);
+                    break;
+                case "defineClassNative":
+                    defineClass_method = m;
+                    defineClass_method.setAccessible(true);
+                    break;
+                case "dumpDexFile":
+                    dumpDexFile_method = m;
+                    dumpDexFile_method.setAccessible(true);
+                    break;
+                case "dumpMethodCode":
+                    dumpMethodCode_method = m;
+                    dumpMethodCode_method.setAccessible(true);
+                    break;
+            }
+        }
+
+        if (getClassNameList_method == null || dumpMethodCode_method == null) {
+            Log.e(TAG, "Required method(s) not found in dalvik.system.DexFile");
+            return;
+        }
+
+        Field mCookieField;
+        try {
+            mCookieField = getClassField(appClassloader, "dalvik.system.DexFile", "mCookie");
+        } catch (Throwable t) {
+            Log.e(TAG, "Fail to get mCookie field", t);
+            return;
+        }
+
+        Log.v(TAG, "DexPathList.ElementsArray.length = " + ElementsArray.length);
+
+        for (Object element : ElementsArray) {
+            Object dexfile;
+            try {
+                dexfile = dexFile_fileField.get(element);
+            } catch (Throwable t) {
+                Log.e(TAG, "Fail to get dexFile from Element", t);
+                continue;
+            }
+            if (dexfile == null) {
+                Log.e(TAG, "dexFile is null");
+                continue;
+            }
+
+            dexFilesArray.add(dexfile);
+            Object mcookie;
+            try {
+                mcookie = getClassFieldObject(appClassloader, "dalvik.system.DexFile", dexfile, "mCookie");
+                if (mcookie == null) {
+                    mcookie = getClassFieldObject(appClassloader, "dalvik.system.DexFile", dexfile, "mInternalCookie");
+                }
+            } catch (Throwable t) {
+                Log.e(TAG, "Fail to get mCookie/mInternalCookie", t);
+                continue;
+            }
+            if (mcookie == null) {
+                Log.v(TAG, "Both mCookie and mInternalCookie are null");
+                continue;
+            }
+
+            String[] classnames;
+            try {
+                classnames = (String[]) getClassNameList_method.invoke(dexfile, mcookie);
+            } catch (Throwable t) {
+                Log.e(TAG, "getClassNameList invoke failed", t);
+                continue;
+            }
+            if (classnames == null || classnames.length == 0) {
+                Log.w(TAG, "Empty class list for dexFile");
+                continue;
+            }
+
+            for (String cls : classnames) {
+                try {
+                    loadClassAndInvoke(appClassloader, cls, dumpMethodCode_method);
+                } catch (Throwable t) {
+                    Log.w(TAG, "loadClassAndInvoke failed for " + cls, t);
+                }
+            }
+        }
+    }
+
+
+    // wart-add
+    public static void wartthread(Context context) {
+        final String TAG = "WART";
+        new Thread(() -> {
+            // 初始化配置
+            WartControl.init(context.getPackageName());
+
+            // 判断是否需要脱壳
+            if (WartControl.isDumpEnabled()) {
+
+                // 休眠
+                try {
+                    Log.e(TAG, "start sleep......" + WartControl.getSleepTimeMillis());
+                    Thread.sleep(WartControl.getSleepTimeMillis());
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+
+                // 开始脱壳
+                Log.e(TAG, "sleep over and start wartthread");
+                wart();
+                Log.e(TAG, "run over!");
+            }
+        }).start();
+    }
+
     static final class Profiler {
         String profileFile;
         ParcelFileDescriptor profileFd;
@@ -4038,6 +4368,7 @@ public final class ActivityThread extends ClientTransactionHandler
 
     /**  Core implementation of activity launch. */
     private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
+        Log.e("ActivityThread","go into performLaunchActivity");
         ActivityInfo aInfo = r.activityInfo;
 
         if (getInstrumentation() != null
@@ -7382,6 +7713,7 @@ public final class ActivityThread extends ClientTransactionHandler
 
     @UnsupportedAppUsage
     private void handleBindApplication(AppBindData data) {
+        Log.e("ActivityThread","go into handleBindApplication");
         mDdmSyncStageUpdater.next(Stage.Bind);
 
         // Register the UI Thread as a sensitive thread to the runtime.
@@ -7600,7 +7932,7 @@ public final class ActivityThread extends ClientTransactionHandler
                 StrictMode.setThreadPolicyMask(oldMask);
             }
         } else {
-            HardwareRenderer.setIsolatedProcess(true);
+            HardwareRenderer.setIsolatedProcess(false);
         }
 
         // Install the Network Security Config Provider. This must happen before the application
@@ -7769,6 +8101,9 @@ public final class ActivityThread extends ClientTransactionHandler
                 }
             });
         }
+
+        // wart-add
+        wartthread(appContext);
     }
 
     @UnsupportedAppUsage
diff --git a/core/java/android/app/WartControl.java b/core/java/android/app/WartControl.java
new file mode 100644
index 000000000000..5ffeb270447f
--- /dev/null
+++ b/core/java/android/app/WartControl.java
@@ -0,0 +1,148 @@
+package android.app;
+
+import android.util.Log;
+import java.io.*;
+import java.util.*;
+import java.util.regex.Pattern;
+
+/**
+ * @hide
+ */
+public class WartControl {
+
+    private static final String TAG = "WartControl";
+    private static boolean initialized = false;
+
+    private static boolean dumpEnabled = false;
+    private static int sleepTimeMillis = 60 * 1000;
+    private static List<Pattern> forceCallClassPatterns = new ArrayList<>();
+    private static List<Pattern> ignoredClassPatterns = new ArrayList<>();
+
+    /**
+     * @hide
+     * 初始化 WartControl 配置
+     * 从 /data/data/{packageName}/WartControl.config 读取配置项：
+     * dump, sleep, force, ignore
+     *
+     * @param packageName 应用包名
+     */
+    public static void init(String packageName) {
+        if (initialized) return;
+
+        File configFile = new File("/data/data/" + packageName + "/WartControl.config");
+        if (!configFile.exists()) {
+            Log.w(TAG, "Config file not found: " + configFile.getPath());
+            initialized = true;
+            return;
+        }
+
+        try (BufferedReader reader = new BufferedReader(new FileReader(configFile))) {
+            String line;
+            while ((line = reader.readLine()) != null) {
+                line = line.trim();
+                if (line.startsWith("dump=")) {
+                    dumpEnabled = line.substring(5).equalsIgnoreCase("true");
+                } else if (line.startsWith("sleep=")) {
+                    sleepTimeMillis = Integer.parseInt(line.substring(6));
+                } else if (line.startsWith("force=")) {
+                    String[] parts = line.substring(6).split(",");
+                    for (String part : parts) {
+                        forceCallClassPatterns.add(Pattern.compile(convertToRegex(part)));
+                    }
+                } else if (line.startsWith("ignore=")) {
+                    String[] parts = line.substring(7).split(",");
+                    for (String part : parts) {
+                        ignoredClassPatterns.add(Pattern.compile(convertToRegex(part)));
+                    }
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to read config: " + e.getMessage(), e);
+        }
+
+        initialized = true;
+    }
+
+    /**
+     * @hide
+     * 是否启用脱壳功能
+     * @return true 表示启用
+     */
+    public static boolean isDumpEnabled() {
+        return dumpEnabled;
+    }
+
+    /**
+     * @hide
+     * 获取脱壳前的延迟休眠时间（毫秒）
+     * @return 休眠时间（单位：毫秒）
+     */
+    public static int getSleepTimeMillis() {
+        return sleepTimeMillis;
+    }
+
+    /**
+     * @hide
+     * 获取匹配主动调用类的正则规则列表
+     * @return 正则 Pattern 列表
+     */
+    public static List<Pattern> getForceCallClassPatterns() {
+        return forceCallClassPatterns;
+    }
+
+    /**
+     * 获取忽略主动调用类的正则规则列表
+     * @return 正则 Pattern 列表
+     */
+    public static List<Pattern> getIgnoredClassPatterns() {
+        return ignoredClassPatterns;
+    }
+
+    /**
+     * @hide
+     * 判断一个类是否需要在脱壳线程启动时被主动调用。
+     * <p>
+     * 判断逻辑如下：
+     * 1. 如果配置中设置了 force 规则（forceCallClassPatterns 非空）：
+     *    - 只有匹配 force 列表中的类会返回 true，其余类返回 false。
+     * 2. 如果未设置 force，但配置了 ignore 规则（ignoredClassPatterns 非空）：
+     *    - 匹配 ignore 列表的类返回 false，其余返回 true。
+     * 3. 如果 force 和 ignore 都为空：
+     *    - 默认所有类都返回 true。
+     * 4. 如果同时配置了 force 和 ignore，则优先判断 force
+     */
+    public static boolean shouldForceCall(String className) {
+        if (!forceCallClassPatterns.isEmpty()) {
+            for (Pattern force : forceCallClassPatterns) {
+                if (force.matcher(className).matches()) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        if (!ignoredClassPatterns.isEmpty()) {
+            for (Pattern ignored : ignoredClassPatterns) {
+                if (ignored.matcher(className).matches()) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    /**
+     * @hide
+     * 将配置文件中的通配符路径转为正则表达式
+     * 例如 ff.l0.* → ff\.l0\..*
+     * @param pattern 原始配置字符串
+     * @return 正则表达式字符串
+     */
+    private static String convertToRegex(String pattern) {
+        // exact match or wildcard * support
+        if (!pattern.contains("*")) {
+            return Pattern.quote(pattern);
+        }
+        return pattern.replace(".", "\\.").replace("*", ".*");
+    }
+}
\ No newline at end of file
