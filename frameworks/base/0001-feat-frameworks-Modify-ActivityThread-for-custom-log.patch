From a9eb07a4775537b54233dd39271d11acdf553a2b Mon Sep 17 00:00:00 2001
From: weixingyu <weixingyu@360.cn>
Date: Wed, 6 Aug 2025 00:55:28 +0800
Subject: [PATCH] feat(frameworks): Modify ActivityThread for custom logic

Change-Id: Ied08d595746fff4f789cdf2f9088013e5d938aa3
---
 core/java/android/app/ActivityThread.java | 351 +++++++++++++++++++++-
 1 file changed, 350 insertions(+), 1 deletion(-)

diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 48b74f2d0776..d80eec1d6834 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -16,6 +16,24 @@
 
 package android.app;
 
+// wart-add
+import android.app.Application;
+import android.util.ArrayMap;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.InputStreamReader;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+
 import static android.app.ActivityManager.PROCESS_STATE_UNKNOWN;
 import static android.app.ConfigurationController.createNewConfigAndUpdateIfNotNull;
 import static android.app.Flags.skipBgMemTrimOnFgApp;
@@ -1002,6 +1020,332 @@ public final class ActivityThread extends ClientTransactionHandler
         }
     }
 
+    // wart-add
+    public static Field getClassField(ClassLoader classloader, String class_name,
+                                      String filedName) {
+
+        try {
+            Class obj_class = classloader.loadClass(class_name);//Class.forName(class_name);
+            Field field = obj_class.getDeclaredField(filedName);
+            field.setAccessible(true);
+            return field;
+        } catch (SecurityException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        }
+        return null;
+
+    }
+
+    // wart-add
+    public static Object getClassFieldObject(ClassLoader classloader, String class_name, Object obj,
+                                             String filedName) {
+
+        try {
+            Class obj_class = classloader.loadClass(class_name);//Class.forName(class_name);
+            Field field = obj_class.getDeclaredField(filedName);
+            field.setAccessible(true);
+            Object result = null;
+            result = field.get(obj);
+            return result;
+        } catch (SecurityException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }
+        return null;
+
+    }
+
+    // wart-add
+    public static Object invokeStaticMethod(String class_name,
+                                            String method_name, Class[] pareTyple, Object[] pareVaules) {
+
+        try {
+            Class obj_class = Class.forName(class_name);
+            Method method = obj_class.getMethod(method_name, pareTyple);
+            return method.invoke(null, pareVaules);
+        } catch (SecurityException e) {
+            e.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (NoSuchMethodException e) {
+            e.printStackTrace();
+        } catch (InvocationTargetException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        }
+        return null;
+
+    }
+
+    // wart-add
+    public static Object getFieldOjbect(String class_name, Object obj,
+                                        String filedName) {
+        try {
+            Class obj_class = Class.forName(class_name);
+            Field field = obj_class.getDeclaredField(filedName);
+            field.setAccessible(true);
+            return field.get(obj);
+        } catch (SecurityException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+        } catch (NullPointerException e) {
+            e.printStackTrace();
+        }
+        return null;
+
+    }
+
+    // wart-add
+    public static ClassLoader getClassloader() {
+        ClassLoader resultClassloader = null;
+        Object currentActivityThread = invokeStaticMethod(
+                "android.app.ActivityThread", "currentActivityThread",
+                new Class[]{}, new Object[]{});
+        Object mBoundApplication = getFieldOjbect(
+                "android.app.ActivityThread", currentActivityThread,
+                "mBoundApplication");
+        Application mInitialApplication = (Application) getFieldOjbect("android.app.ActivityThread",
+                currentActivityThread, "mInitialApplication");
+        Object loadedApkInfo = getFieldOjbect(
+                "android.app.ActivityThread$AppBindData",
+                mBoundApplication, "info");
+        Application mApplication = (Application) getFieldOjbect("android.app.LoadedApk", loadedApkInfo, "mApplication");
+        resultClassloader = mApplication.getClassLoader();
+        return resultClassloader;
+    }
+
+    // wart-add
+    public static void loadClassAndInvoke(ClassLoader appClassloader, String eachclassname, Method dumpMethodCode_method) {
+        Class resultclass = null;
+        Log.i("ActivityThread", "go into loadClassAndInvoke->" + "classname:" + eachclassname);
+        try {
+            resultclass = appClassloader.loadClass(eachclassname);
+        } catch (Exception e) {
+            e.printStackTrace();
+            return;
+        } catch (Error e) {
+            e.printStackTrace();
+            return;
+        }
+        if (resultclass != null) {
+            try {
+                Constructor<?> cons[] = resultclass.getDeclaredConstructors();
+                for (Constructor<?> constructor : cons) {
+                    if (dumpMethodCode_method != null) {
+                        try {
+                            dumpMethodCode_method.invoke(null, constructor);
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        } catch (Error e) {
+                            e.printStackTrace();
+                        }
+                    } else {
+                        Log.e("ActivityThread", "dumpMethodCode_method is null ");
+                    }
+
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            } catch (Error e) {
+                e.printStackTrace();
+            }
+            try {
+                Method[] methods = resultclass.getDeclaredMethods();
+                if (methods != null) {
+                    for (Method m : methods) {
+                        if (dumpMethodCode_method != null) {
+                            try {
+                                dumpMethodCode_method.invoke(null, m);
+                            } catch (Exception e) {
+                                e.printStackTrace();
+                            } catch (Error e) {
+                                e.printStackTrace();
+                            }
+                        } else {
+                            Log.e("ActivityThread", "dumpMethodCode_method is null ");
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            } catch (Error e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    // wart-add
+    public static void wart() {
+        ClassLoader appClassloader = getClassloader();
+        ClassLoader parentClassloader = appClassloader.getParent();
+        if(!appClassloader.toString().contains("java.lang.BootClassLoader"))
+        {
+            wartWithClassloader(appClassloader);
+        }
+        while(parentClassloader != null){
+            if(!parentClassloader.toString().contains("java.lang.BootClassLoader"))
+            {
+                wartWithClassloader(parentClassloader);
+            }
+            parentClassloader = parentClassloader.getParent();
+        }
+    }
+
+    // wart-add
+    public static void wartWithClassloader(ClassLoader appClassloader) {
+        final String TAG = "Wart";
+
+        List<Object> dexFilesArray = new ArrayList<>();
+        Field pathList_Field;
+        Object pathList_object;
+        Object[] ElementsArray;
+        Field dexFile_fileField;
+        Class<?> DexFileClazz;
+        Method getClassNameList_method = null;
+        Method dumpMethodCode_method = null;
+        Method defineClass_method = null;
+        Method dumpDexFile_method = null;
+
+        try {
+            pathList_Field = getClassField(appClassloader, "dalvik.system.BaseDexClassLoader", "pathList");
+            pathList_object = getFieldOjbect("dalvik.system.BaseDexClassLoader", appClassloader, "pathList");
+            ElementsArray = (Object[]) getFieldOjbect("dalvik.system.DexPathList", pathList_object, "dexElements");
+
+            dexFile_fileField = getClassField(appClassloader, "dalvik.system.DexPathList$Element", "dexFile");
+            DexFileClazz = appClassloader.loadClass("dalvik.system.DexFile");
+        } catch (Throwable t) {
+            Log.e(TAG, "Fail to get DexPathList or DexFile class/field", t);
+            return;
+        }
+
+        for (Method m : DexFileClazz.getDeclaredMethods()) {
+            switch (m.getName()) {
+                case "getClassNameList":
+                    getClassNameList_method = m;
+                    getClassNameList_method.setAccessible(true);
+                    break;
+                case "defineClassNative":
+                    defineClass_method = m;
+                    defineClass_method.setAccessible(true);
+                    break;
+                case "dumpDexFile":
+                    dumpDexFile_method = m;
+                    dumpDexFile_method.setAccessible(true);
+                    break;
+                case "dumpMethodCode":
+                    dumpMethodCode_method = m;
+                    dumpMethodCode_method.setAccessible(true);
+                    break;
+            }
+        }
+
+        if (getClassNameList_method == null || dumpMethodCode_method == null) {
+            Log.e(TAG, "Required method(s) not found in dalvik.system.DexFile");
+            return;
+        }
+
+        Field mCookieField;
+        try {
+            mCookieField = getClassField(appClassloader, "dalvik.system.DexFile", "mCookie");
+        } catch (Throwable t) {
+            Log.e(TAG, "Fail to get mCookie field", t);
+            return;
+        }
+
+        Log.v(TAG, "DexPathList.ElementsArray.length = " + ElementsArray.length);
+
+        for (Object element : ElementsArray) {
+            Object dexfile;
+            try {
+                dexfile = dexFile_fileField.get(element);
+            } catch (Throwable t) {
+                Log.e(TAG, "Fail to get dexFile from Element", t);
+                continue;
+            }
+            if (dexfile == null) {
+                Log.e(TAG, "dexFile is null");
+                continue;
+            }
+
+            dexFilesArray.add(dexfile);
+            Object mcookie;
+            try {
+                mcookie = getClassFieldObject(appClassloader, "dalvik.system.DexFile", dexfile, "mCookie");
+                if (mcookie == null) {
+                    mcookie = getClassFieldObject(appClassloader, "dalvik.system.DexFile", dexfile, "mInternalCookie");
+                }
+            } catch (Throwable t) {
+                Log.e(TAG, "Fail to get mCookie/mInternalCookie", t);
+                continue;
+            }
+            if (mcookie == null) {
+                Log.v(TAG, "Both mCookie and mInternalCookie are null");
+                continue;
+            }
+
+            String[] classnames;
+            try {
+                classnames = (String[]) getClassNameList_method.invoke(dexfile, mcookie);
+            } catch (Throwable t) {
+                Log.e(TAG, "getClassNameList invoke failed", t);
+                continue;
+            }
+            if (classnames == null || classnames.length == 0) {
+                Log.w(TAG, "Empty class list for dexFile");
+                continue;
+            }
+
+            for (String cls : classnames) {
+                try {
+                    loadClassAndInvoke(appClassloader, cls, dumpMethodCode_method);
+                } catch (Throwable t) {
+                    Log.w(TAG, "loadClassAndInvoke failed for " + cls, t);
+                }
+            }
+        }
+    }
+
+
+    // wart-add
+    public static void wartthread() {
+        new Thread(() -> {
+            try {
+                Log.e("ActivityThread", "start sleep...");
+                Thread.sleep(60_000);
+            } catch (InterruptedException e) {
+                Log.e("ActivityThread", "sleep interrupted", e);
+                Thread.currentThread().interrupt();
+            }
+            Log.e("ActivityThread", "sleep over and start wart");
+            wart();
+            Log.e("ActivityThread", "wart run over");
+        }, "wart-thread").start();
+    }
+
+
     static final class Profiler {
         String profileFile;
         ParcelFileDescriptor profileFd;
@@ -4038,6 +4382,7 @@ public final class ActivityThread extends ClientTransactionHandler
 
     /**  Core implementation of activity launch. */
     private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
+        Log.e("ActivityThread","go into performLaunchActivity");
         ActivityInfo aInfo = r.activityInfo;
 
         if (getInstrumentation() != null
@@ -4207,6 +4552,9 @@ public final class ActivityThread extends ClientTransactionHandler
             }
         }
 
+        // wart-add
+        wartthread();
+
         return activity;
     }
 
@@ -7382,6 +7730,7 @@ public final class ActivityThread extends ClientTransactionHandler
 
     @UnsupportedAppUsage
     private void handleBindApplication(AppBindData data) {
+        Log.e("ActivityThread","go into handleBindApplication");
         mDdmSyncStageUpdater.next(Stage.Bind);
 
         // Register the UI Thread as a sensitive thread to the runtime.
@@ -7600,7 +7949,7 @@ public final class ActivityThread extends ClientTransactionHandler
                 StrictMode.setThreadPolicyMask(oldMask);
             }
         } else {
-            HardwareRenderer.setIsolatedProcess(true);
+            HardwareRenderer.setIsolatedProcess(false);
         }
 
         // Install the Network Security Config Provider. This must happen before the application
-- 
2.43.0

